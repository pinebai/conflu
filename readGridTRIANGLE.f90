! ******************************************************************************
!
! $Id: readGridTRIANGLE.f90,v 1.1 2005/03/05 17:25:53 haselbac Exp $
!
! Filename: readGridTRIANGLE.F90
!
! Purpose: Read 2d grid file in TRIANGLE format.
!
! Description: None.
!
! Input: None.
!
! Output: None.
!
! Notes: 
!   1. To convert a TRIANGLE grid, three grid files need to be generated by 
!      TRIANGLE: a .node, a .ele. and a .edge file. The .edge file is needed
!      to construct the boundary edge data structure; note that it will only 
!      be generated by TRIANGLE if the -e switch is specified.
!
! Author: Andreas Haselbacher
!
! Copyright: (c) 2004 by the University of Illinois
!
! RCS Revision history:
!
! $Log: readGridTRIANGLE.f90,v $
! Revision 1.1  2005/03/05 17:25:53  haselbac
! Initial revision
!
! Revision 1.1  2004/01/13 03:45:22  haselbac
! Initial revision
!
! ******************************************************************************

SUBROUTINE readGridTRIANGLE

  USE modError
  USE modGlobals
  USE modGrid

  IMPLICIT NONE

! ******************************************************************************
! Declarations and definitions
! ******************************************************************************

! ==============================================================================
! Local variables
! ==============================================================================

  INTEGER :: bType,dummyInteger,ib,ic,ie,iFile,iv,nEdges,v1,v2
  INTEGER, DIMENSION(:,:), ALLOCATABLE :: boundMap,c2v
  CHARACTER :: choice
  CHARACTER*(MAX_STRING_LEN) :: dummyString,iFileName,iFileNameBase

! ******************************************************************************
! Start
! ******************************************************************************

  WRITE(STDOUT,'(/,1X,A)') 'Enter file name (without .<n>.<ext>):'
  READ(STDIN,'(A)') iFileNameBase
  WRITE(STDOUT,'(/)')

  WRITE(STDOUT,'(1X,A)') 'Reading grid file in TRIANGLE format...'

! ******************************************************************************
! Read .node file
! ******************************************************************************

  iFile = FILE_UNIT_GRID_INPUT
  iFileName = TRIM(iFileNameBase)//'.1.node'

  OPEN(iFile,FILE=iFileName,FORM="FORMATTED",STATUS="OLD",IOSTAT=errorFlag)
  IF ( errorFlag /= NO_ERROR ) THEN
    CALL errorHandling(FILE_OPEN_ERROR,iFileName,errorFlag)
  END IF ! errorFlag

  READ(iFile,*) grid%nVert

! ==============================================================================
! Read coordinates
! ==============================================================================

  ALLOCATE(grid%xy(2,grid%nVert),STAT=errorFlag)
  IF ( errorFlag /= NO_ERROR ) THEN
    CALL errorHandling(ALLOCATE_ERROR,'grid%xy',errorFlag)
  END IF ! errorFlag

  WRITE(STDOUT,'(3X,A)') 'Coordinates...'

  DO iv = 1,grid%nVert
    READ(iFile,*) dummyInteger,grid%xy(1,iv),grid%xy(2,iv)
  END DO ! iv

  CLOSE(iFile,IOSTAT=errorFlag)
  IF ( errorFlag /= NO_ERROR ) THEN
    CALL errorHandling(FILE_CLOSE_ERROR,iFileName,errorFlag)
  END IF ! errorFlag
  
! ******************************************************************************
! Read .ele file
! ******************************************************************************

  iFile = FILE_UNIT_GRID_INPUT
  iFileName = TRIM(iFileNameBase)//'.1.ele'

  OPEN(iFile,FILE=iFileName,FORM="FORMATTED",STATUS="OLD",IOSTAT=errorFlag)
  IF ( errorFlag /= NO_ERROR ) THEN
    CALL errorHandling(FILE_OPEN_ERROR,iFileName,errorFlag)
  END IF ! errorFlag

  READ(iFile,*) grid%nTris

  ALLOCATE(grid%tri2v(3,grid%nTris),STAT=errorFlag)
  IF ( errorFlag /= NO_ERROR ) THEN
    CALL errorHandling(ALLOCATE_ERROR,'grid%tri2v',errorFlag)
  END IF ! errorFlag

  WRITE(STDOUT,'(3X,A)') 'Connectivity...'
      
  DO ic = 1,grid%nTris
    READ(iFile,*) dummyInteger,grid%tri2v(1,ic), &
                               grid%tri2v(2,ic), & 
                               grid%tri2v(3,ic)
  END DO ! ic

  grid%nQuads = 0
  grid%nCells = grid%nTris

  CLOSE(iFile,IOSTAT=errorFlag)
  IF ( errorFlag /= NO_ERROR ) THEN
    CALL errorHandling(FILE_CLOSE_ERROR,iFileName,errorFlag)
  END IF ! errorFlag

! ******************************************************************************
! Read .edge file
! ******************************************************************************

  iFile = FILE_UNIT_GRID_INPUT
  iFileName = TRIM(iFileNameBase)//'.1.edge'

  OPEN(iFile,FILE=iFileName,FORM="FORMATTED",STATUS="OLD",IOSTAT=errorFlag)
  IF ( errorFlag /= NO_ERROR ) THEN
    CALL errorHandling(FILE_OPEN_ERROR,iFileName,errorFlag)
  END IF ! errorFlag

  WRITE(STDOUT,'(3X,A)') 'Boundaries...'

! ==============================================================================
! Determine number of boundaries 
! ==============================================================================

  READ(iFile,*) nEdges

  ALLOCATE(boundMap(2,NBOUNDS_MAX),STAT=errorFlag)
  IF ( errorFlag /= NO_ERROR ) THEN
    CALL errorHandling(ALLOCATE_ERROR,'grid%tri2v',errorFlag)
  END IF ! errorFlag
  
  DO ib = 1,NBOUNDS_MAX
    boundMap(1,ib) = 0
    boundMap(2,ib) = 0    
  END DO ! ib
  
  DO ie = 1,nEdges
    READ(iFile,*) dummyInteger,dummyInteger,dummyInteger,ib
    
    IF ( ib > 0 .AND. ib <= NBOUNDS_MAX ) THEN 
      boundMap(1,ib) = boundMap(1,ib) + 1
    ELSE IF ( ib > NBOUNDS_MAX ) THEN 
      CALL errorHandling(NBOUNDS_MAX_ERROR)   
    END IF ! ib
  END DO ! ie

  grid%nBounds = 0 

  DO ib = 1,NBOUNDS_MAX
    IF ( boundMap(1,ib) /= 0 ) THEN 
      grid%nBounds = grid%nBounds + 1
      boundMap(2,ib) = grid%nBounds
    END IF ! boundMap
  END DO ! ib

  WRITE(STDOUT,'(5X,A,1X,I2,1X,A)') 'Detected',grid%nBounds,'boundaries.'
  WRITE(STDOUT,'(5X,A,1X,A)') 'Boundary','nEdges' 
  
  DO ib = 1,grid%nBounds
    WRITE(STDOUT,'(6X,1X,I2,5X,I4)') ib,boundMap(1,ib)
  END DO ! ib

! ==============================================================================
! Allocate memory for boundary type
! ==============================================================================
      
  ALLOCATE(grid%bound(grid%nBounds),STAT=errorFlag)
  IF ( errorFlag /= NO_ERROR ) THEN
    CALL errorHandling(ALLOCATE_ERROR,'grid%bound',errorFlag)
  END IF ! errorFlag

  DO ib = 1,grid%nBounds
    grid%bound(ib)%nEdges = boundMap(1,ib)
        
    ALLOCATE(grid%bound(ib)%e2v(2,grid%bound(ib)%nEdges),STAT=errorFlag)
    IF ( errorFlag /= NO_ERROR ) THEN
      CALL errorHandling(ALLOCATE_ERROR,'grid%bound%e2v',errorFlag)
    END IF ! errorFlag 
        
    grid%bound(ib)%nEdges = 0 ! Reset         
  END DO ! ib

! ==============================================================================
! Assign boundary conditions to existing boundaries 
! ==============================================================================

  WRITE(STDOUT,'(5X,A)') 'Assign boundary numbers from following selection:'
  WRITE(STDOUT,'(7X,A)') '100 - Inflow'
  WRITE(STDOUT,'(7X,A)') '200 - Outflow'
  WRITE(STDOUT,'(7X,A)') '300 - No-slip wall'
  WRITE(STDOUT,'(7X,A)') '400 - Slip wall'
  WRITE(STDOUT,'(7X,A)') '500 - Farfield'

  DO ib = 1,grid%nBounds
    WRITE(STDOUT,'(5X,A,1X,I2)') 'Enter boundary number for boundary:',ib
    READ(STDIN,*) grid%bound(ib)%bType
  END DO ! ib

! ==============================================================================
! Rewind file and read again to get boundary edge connectivity
! ==============================================================================

  REWIND(iFile)
    
  READ(iFile,*) dummyInteger
  
  DO ie = 1,nEdges
    READ(iFile,*) dummyInteger,v1,v2,ib
    
    IF ( ib > 0 ) THEN 
      grid%bound(ib)%nEdges = grid%bound(ib)%nEdges + 1
      
      grid%bound(ib)%e2v(1,grid%bound(ib)%nEdges) = v1
      grid%bound(ib)%e2v(2,grid%bound(ib)%nEdges) = v2
    END IF ! ib
  END DO ! ie  

! ******************************************************************************
! Close file
! ******************************************************************************

  CLOSE(iFile,IOSTAT=errorFlag)
  IF ( errorFlag /= NO_ERROR ) THEN
    CALL errorHandling(FILE_CLOSE_ERROR,iFileName,errorFlag)
  END IF ! errorFlag

  WRITE(STDOUT,'(1X,A,/)') 'Grid file read successfully.'

! ******************************************************************************
! End
! ******************************************************************************

END SUBROUTINE readGridTRIANGLE
